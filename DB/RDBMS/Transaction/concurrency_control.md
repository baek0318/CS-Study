# 병행제어

`병행 제어` : 각각의 트랜잭션이 서로 방해받지 하지 않고 수행하도록 제어하는 것을 이야기한다   
`병행 수행` : 여러 트랜잭션이 동시에 실행되는 것을 이야기하고 실제로는 cpu가 context switch를 하듯 번갈아가며 수행한다

## 병행 수행의 문제
병행 수행을 특별한 제어없이 실행할 경우 발생할 수 있는 문제점 
### 갱신 분실
트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것이다  

### 모순성
트랜잭션이 여러개의 데이터 변경 연산을 실행할때 일관성이 없는 상태의 데이터를 가져와 연산을 실행함으로써 정확한 결과값이 나오지 않는 경우를 이야기한다

### 연쇄 복귀
트랜잭션이 완료되기전에 장애가 발생하여서 rollback을 해야하는 상황이라면  
동일한 데이터로 다른 트랜잭션이 연산을 진행중이라면 같이 rollback을 해야하는 상황을 이야기한다  
하지만 다른 트랜잭션이 해당 데이터에 대해 이미 commit을 완료했다면 굉장한 문제가 발생할 수 도 있다  


## 트랜잭션 스케줄
병행 수행을 진행하게 된다면 인터리빙 방식을 사용한다  
트랜잭션의 연산 수행 순서에 따라서 결과값이 달라지게 된다  
그러므로 트랜잭션 연산의 순서가 굉장히 중요하다

### 직렬 스케줄
인터리빙 방식을 사용하지 않고 각 트랜잭션별로 연산들을 순차적으로 실행시키는 것이다   
- `장점` : 항상 모순이 없는 정확한 결과를 얻는다  
- `단점` : 트랜잭션이 동시에 수행되지 않아서 병행수행이라고 보기 힘들다  

### 비직렬 스케줄
인터리빙 방식을 이용하여 트랜잭션을 병행해서 수행시키는 것이다  
- `장점` : 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션을 실행시킬 수 있다  
- `단점` : 최종수행 결과의 정확성을 보장할 수 없다  

### 직렬 기능 스케줄 
직렬 스케줄에 따라 수행한 것과 같이 정확한 결과를 생성하는 비직렬 스케줄이다  
- `장점` : 트랜잭션을 동시에 실행도 하고 직렬 스케줄과 같은 결과값을 가질 수 있다  
- `단점` : 직렬 가능한 스케줄인지 판단하기가 쉽지 않다

## 병행제어 기법
여러 트랜잭션을 병행 수행 하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 사용된다  

### 로킹 기법의 개념
locking 기법은 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 하는 것이다  
즉 상호배제하여 직렬가능성을 보장하는 것이다  
- `lock` : 트랜잭션이 사용할 데이터에 대한 독점권을 가지기 위해 사용한다  
- `unlock` : 독점한 데이터를 반납하기 위해 사용한다  

### lock 연산의 종류
- `Shared lock` : 다른 트랜잭션이 해당 데이터에 read 연산을 실행할 수 있지만 write 연산은 실행할 수 없다
    - 데이터에 대한 사용권을 여러 트랜잭션이 같이 가질 수 있다 
- `exclusive lock` : 다른 트랜잭션이 해당 데이터에 read, write 둘다 사용할 수 없다
    - 데이터에 대한 단일 트랜잭션의 독점 
    

### 2단계 로킹 규약
기본 로킹 규약만 사용해서는 완전한 직렬가능성을 보장할 수 가 없어서 추가적으로 규약을 주는 것이 2단계 로킹 규약이다  
lock과 unlock 연산의 시점에 대해 규약을 정해준다  

- `확장 단계` : 트랜잭션이 lock 연산만 실행 할 수 있는 단계 
- `축소 단계` : 트랜잭션이 unlock 연산만 실행 할 수 있는 단계

트랜잭션이 시작하면 확장단계가 된다  
unlock을 하면 lock을 할 수 없기 때문에 반드시 필요한 lock을 다한 뒤에 unlock을 해야한다  
  

`단점` : Deadlock이 발생할 수 있다 


