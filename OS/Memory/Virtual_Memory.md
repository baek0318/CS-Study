# 가상 메모리

>Created: 2021년 4월 6일 오전 11:59  
>Property: 익명  
>Tags: `Memory`, `Virtual`  

### 가상 메모리 공간

일반적으로 물리 메모리 공간은 한정적으로 구성되어져 있다

하지만 한정된 물리 메모리 공간에 구애받지 않고 애플리케이션을 만들 수 있도록 해주는 것이 가상메모리 공간이다

가상 메모리 공간은 쉽게 얘기해서 `물리 메모리 + 스왑 영역`로 볼 수 있다

프로세스가 느끼기에 자신의 모든 부분이 메모리에 올라갔다고 느낀다

하지만 실제로는 특정 부분은 물리 메모리에 올라가있고 나머지는 스왑 영역에 배치되어져 있다

### 논리 주소와 가상 주소의 차이점

- 논리 주소는 물리 주소 공간에 비례
- 가상 주소는 물리 주소 공간과 별도의 가상 주소의 공간

### 메모리 관리자의 역할

메모리 관리자는 매핑 테이블을 이용해서 가상 주소공간을 실제 주소공간으로 연결시켜주는 역할을 한다

VA = <P, D>

PA = <F, D>

형태로 주소 공간의 위치를 표현할 수 있다

va = 0, 2 → pa = 1, 2 가 된다 즉 P, F값만 변경되고 D의 값은 변경되지 않는다

## 가상 메모리 공간 관리 방법

### 페이징 (고정 주소 할당 방식)

페이지 테이블을 통해서 페이지 위치 → 프레임 위치 로 변경해준다

페이지 테이블은 프로세스마다 개별적으로 가지고 운영체제가 자주 접근하기 때문에 메모리 영역에 거주한다

메모리 영역에서 어디에 위치하는지 표현해 주는 것이 `PTBR` 를 통해서 찾을 수 있다

**페이지 테이블 관리 방법**

1. `직접 매핑`

   모든 테이블을 메모리에서 관리한다

2. `연관 매핑`

   테이블 자체는 스왑 영역에 두고 필요한 부분만 가져와서 사용한다

   물리 메모리에 가져온 일부분을 `TLB`라고 부른다

   TLB에 원하는 페이지가 존재한다면 TLB히트 존재하지 않는다면 TLB 미스가 발생한다

   하지만 TLB 미스가 발생한다면 스왑영역에서 원하는 페이지 테이블을 가져와야 한다

    - 단점

      TLB 미스가 발생하는 것을 알려면 모든 TLB를 검색하고 난 다음이여서 비효율적이다

3. `집합 연관 매핑`

   관련 있는 페이지끼리 모아 놓은 형태를 이야기한다

   `디렉터리 테이블` : 특정한 테이블 묶음이 현재 메모리에 있는지 스왑 영역에 있는지 확인 해주는 테이블 PTBR이 관리한다

    1. 가상 주소 공간이 주어진다
    2. 해당 주소 공간을 포함하는 페이지 묶음이 현재 메모리에 올라왔는지 확인한다
        1. 올라 왔다면 해당 페이지 묶음의 위치를 알려준다
        2. 아니라면 스왑 영역으로 가서 페이지 묶음을 가져온다
    3. 페이지 묶음에 도착했다면 가상 메모리 주소를 실제 메모리 주소로 변경한다
    - 장점

      연관 매핑과 다르게 miss 발생을 빠르게 알아차릴 수 있다

      효율적엔 페이지 테이블 관리가 가능하다

    1. `역매핑`

       일반적으로 페이지를 가지고 프레임 주소를 찾는 방식이 아니라

       반대로 특정 프레임 번호에 어떤 PID의 페이지가 올라와 있는지 표현해준다

       그러므로 페이지 테이블의 크기는 일정 크기만큼만 항상 유지할 수 있다


### 세그먼테이션 (가변 주소 할당 방식) → 잘안씀

물리 메모리 가변 주소 할당방식과 비슷하게

프로세스를 나눌때 일정한 크기로 나누는 것이 아니라 기능별로 분리를 해서 메모리 공간에 적재하는 것을 이야기한다

이렇게 하게 되면 외부 단편화가 발생하게 된다

### PTE

페이지 테이블 엔트리로써 페이지 테이블의 하나의 행을 구성하고 있는 것이다

### Page fault

페이지 테이블에 프로세스가 요청한 페이지가 존재하지 않는 경우를 이야기한다

존재 유무의 판단은 PTE의 valid bit의 값을 보고 판단할 수 있다

- 물리 메모리가 가득 찬 경우

  이런 경우에서는 swap in out을 통해서 필요없다고 판단되는 페이지는 스왑 영역으로 내보내고 필요하다고 판단되는 페이지는 스왑 영역에서 가져온다


### 지역성

페이지 교체 알고리즘을 작성하거나 캐싱 메모리를 생성할 때 얼마나 정확하게 필요한 정보를 가져오느냐를 예측할 때 필요한 것이다

- 공간의 지역성

  현재 접근 중인 데이터가 있는 위치 주변의 데이터에 접근할 확률이 크다것을 의미한다

- 시간의 지역성

  가장 최근에 접근한 데이터가 더 예전에 접근한 데이터보다 사용할 확룰이 크다는 것을 의미한다


## 페이지 교체 알고리즘

### FIFO

물리 메모리가 가득 찬 경우에 가장 먼저 들어온 페이지를 내보내는 알고리즘

- 변형 알고리즘
    - 2차 기회 페이지 교체 알고리즘

      FIFO에서는 무조건 먼저 들어온 페이지를 내보냈다면

      여기서는 자신이 대상 페이지로 선정되기 전에 한번 더 hit를 한다면 제일 뒤로 보냄으로써 대상 페이지에서 제외 시켜주는 알고리즘을 이야기한다


### OPT

앞으로 사용하지 않을 것이라고 추측되는 페이지를 swap out 시키는 것을 이야기한다

- 장점
    - 미래의 데이터를 기반으로 하기 때문에 성공 확률이 높다
- 단점
    - 구현 할 수 가 없다

### LRU

메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 swap out 하는 것을 이야기한다

- 구현 방법
    - 페이지 접근 시간에 기반한 구현

      페이지 마다 최근에 접근한 시간을 기록함으로써 페이지 교체때 사용된다

    - 카운터에 기반한 구현

      시간과 비슷한데 시간대신에 카운터로 보는 것이다

      결국에는 시간과 거의 유사하다

    - 참조 비트 시프트 방식

      1바이트 공간을 할당해서 참조가 될때마다 해당 페이지의 제일 앞에 비트를 1로 기록하고 시간이 지날 때마다 뒤로 한칸씩 미룬다

      그러다가 페이지 교체할 때가 되면 1바이트를 십진수로 변환해 더 작은 수를 교체한다


## Thrashing

적절하게 프레임의 크기를 할당해주지 못해서 HDD와 너무 빈번하게 작업을 하게 된다면 CPU의 작업이 멈춘것 처럼 보이는 상태를 이야기한다

프로그램을 한꺼번에 많이 실행하는 경우가 있는데 처음에는 프로그램이 실행이 많이 될수록 cpu의 사용률이 증가한다 하지만 스레싱 발생 시점을 넘는 순간부터 cpu 사용률이 매우 낮아지는 현상이 발생하게 된다

왜냐하면 많은 시간을 cpu 사용이 아니라 HDD의  I/O에 사용하기 때문이다

- 해결 방법

  프레임의 크기를 적절하게 맞춰줌으로써 page fault가 발생하지 않도록 해줘야한다


### 프레임 할당 방식

- 정적 할당

  실행 초기에 프레임을 나눠준 후 그 크기를 고정하는 것이다

    - 균등 할당

      프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에게 동일하게 할당한다

    - 비례 할당

      프로세스의 크기에 비례하여서 프레임의 크기를 할당해준다

        - 문제점
            - 프로세스가 실행 중에 필요로 하는 것을 유동적으로 반영하기 어렵다
            - 사용하지 않을 메모리를 미리 확보하여 공간을 낭비한다
- 동적 할당

  프로세스가 실행될때마다 프레임의 크기를 동적으로 변환해줌으로 최적의 프레임의 크기를 찾는 것이다

    - 작업 집합 모델

      최근 일정 기간동안 참조된 페이지들을 집합으로 만들어서 메모리에 유지하는 것을 이야기한다

        - 문제점
            - 프로세스마다 프레임을 얼마나 할당해야하는 지는 알 수 없다
    - 페이지 부재 빈도

      페이지 부재율의 비율을 상한선 하한선으로 설정함으로써 상한선을 넘어가면 크기를 늘이고 하한선 밑으로 내려가면 크기를 줄인다