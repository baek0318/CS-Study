# TCP
>Author: 백승화  
>Created: 2021년 10월 3일  
>Tags: `tcp`

## TCP 연결
TCP 프로토콜인 경우에는 애플리케이션 프로레스가 데이터를 다른 프로세스에게 보내기 전에  
두 프로세스가 서로 핸드셰이크를 먼저해야하므로 연결지향형이다  
### 특징
- 종단간 시스템에서만 동작
  - tcp는 프로세스와 프로세스 사이에서 작동하는 것이기 때문에  
    중간에 패킷을 전달하는 네트워크 요소인 라우터나 스위치에서는 tcp연결상태를 유지하지 않는다 
- 점대점
  - 하나의 송신자가 여러명의 수신자에게 한꺼번에 메세지를 전달하는 행위를 하지 못한다  
    하나의 송신자는 하나의 수신자에게만 데이터를 전달해야한다
- 전이중 서비스
  - a와 b사이에 tcp연결이 확립되어있다면  
    a->b로 보내는 동시에 b->a로 보낼 수 있다  
    
## TCP 세그먼트 구조

### 순서번호와 확인응답 번호
- `순서번호` : 데이터 스트림을 사이즈에 맞게 자르는데 해당 사이즈마다 첫번째 데이터 스트림의 번호를 이야기한다  
          예) 1500 길이를 3으로 나눈다면 순서번호는 0, 500, 1000이 된다
  
- `확인응답번호` : 호스트 A가 호스트 B로 부터 데이터를 받은 경우 호스트 A는 호스트 B에게 바라는 다음 데이터의 순서번호를 적는 공간이다

**TCP에서 순서가 바껴서 도착한 경우**  
개발자의 구현에 따라서 다르다  
1. 수신자가 순서가 틀린 세그먼트를 버린다
2. 수신자가 순서가 틀린 세그먼트는 버퍼링을하고 제대로된 응답이 들어올때 까지 기다린다  

**실제로 순서번호를 설정하는 방식**  
실제로 순서번호를 설정하는 방법은 난수를 사용하는 방법이다  
왜냐하면 동일한 출발지 목적지 포트에서 새로운 연결설정을 했을 때  
네트워크에 남아있던 패킷이 목적지 포트나 출발지 포트에 도착한 경우  
이전의 데이터인지 현재 데이터인지 구분하기가 어렵기 때문이다  

## 신뢰적 데이터 전송 방법
트랜스포트 계층 하위에 존재하는 네트워크 계층에서 사용되는 ip는 데이터에대한 어떠한 것도 보장해주지 못한다  
그래서 트랜스포트 계층에서 tcp 프로토콜을 사용하게 된다면  
애플리케이션 계층에서는 데이터를 손실없이 순서대로 받을 수 있게끔 보장해준다  

rdt와의 차이점은 어떠한 상황에서도 단일 타이머를 사용한다  

### 응답 시나리오
1. 패킷을 전달하고 ack패킷을 시간내에 받지 못한경우
2. 순서번호 92, 100 패킷을 연속해서 보냈는데 ack응답이 첫번째 시간에 못들어오고 두번째 시간에 들어온 경우
3. 순서번호 92, 100 패킷을 연속해서 보냈는데 92 응답은 도착하지 못하고 100 응답만 도착한경우 

### 타임아웃 주기 설정
예를 들어서 초기에 0.75초 라고 설정을 했는데 타임아웃이 발생한다면  
그 다음 시간을 1.5초로 설정하고 또 타임아웃이 발생한다면 `시간*2` 를 함으로 재설정해준다  

**예외**  
상위 애플리케이션으로부터 데이터를 전달받는 경우와 ACK를 수신한 경우에는  
EstimatedRTT, DevRTT를 사용한다  

### 빠른 재전송
특정 패킷이 손실되고 해당 패킷에 대한 타임아웃이 발생하기전에 패킷이 손실되었음을 알고 재전송하는 방법이다    

**어떻게 알 수 있냐면**  
수신자가 누적 ack로 가지고 있는 최근의 ack가 100이라면  
101번째 순서번호의 패킷이 손실되었고  
그 뒤로 전송된 3개의 패킷이 제대로 수신자측에 전송되었다면  
수신자 측에 정상적으로 전달된 3개의 패킷의 ack로 100이 중복 ack로 송신자측에 전달되게 된다  
송신자측은 3개의 연속된 중복 ack를 받음으로써 101번째 패킷이 손실 되었음을 알고 빠른 재전송을 하게된다  


## 흐름제어
a, b가 tcp 연결을 하였을 때에 전이중 통신의 특징으로 인해서 둘 다 송수신버퍼를 하나씩 생성하게 된다  
그리고 각각의 애플리케이션은 각자의 수신버퍼에서 필요할때마다 데이터를 가져감으로 수신버퍼를 비워준다  
하지만 애플리케이션이 수신버퍼에서 데이터를 꺼내는 속도와 송신자가 데이터를 수신버퍼로 집어넣는 속도가 차이가 발생하게 되면  
수신자측의 수신버퍼는 오버플로우가 발생해서 데이터 손실이 발생하게 된다  
이러한 `애플리케이션 <-> 수신 버퍼 <-> 송신자` 사이의 속도를 맞추는 것이 `흐름제어`이다
**물론 udp는 지원하지 않는다**  

### 해결방법
수신 윈도우라는 tcp 헤더의 공간이 존재하는데 해당 필드를 이용한다  
수신자는 송신자에게 데이터를 전달 받을때마다 ack응답 패킷에 수신 윈도우 필드에 버퍼의 남은 크기를 같이 보낸다  
그래서 송신자는 그것을 확인해서 데이터를 많이 보낼지 적게 보낼지 선택한다  

**문제점**  
수신자가 더이상 남은 공간이 없다고 응답 패킷을 보내게 된다면  
송신자는 추후에 수신자에게 공간이 남게 되더라도 남은 데이터를 보내지 못하게 된다  

**문제점 해결방법**  
더이상 공간이 없다는 패킷을 수신자에게 받게 된다면  
송신자는 1분마다 1바이트 크기의 패킷을 보냄으로써 수신자에게 공간이 얼마 남았는지 주기적으로 물어봄으로써 해결한다  

## 연결성 관리
tcp는 전이중 통신과 점대점 통신과 신뢰적 데이터 전송이라는 특징을 가지고 있고  
특히 신뢰적 데이터 전송을 하기위해서 둘 사이의 연결성을 만들고 없에는 것을 이야기한다  

### 연결 생성
tcp 연결을 생성하는 것을 three way handshake라고 한다  

**연결성 생성 순서**
1. 헤더의 SYN 플래그 비트를 1로 설정한 패킷을 연결하고 싶은 서버에 전송한다  
   `의미` : "나 여기에 있고 연결을 하기 원해"
2. 서버는 SYN 플래그 비트를 1로 설정하고 ACK 응답이 담긴 패킷을 클라이언트에게 전송한다  
    `의미` : "연결알겠고 나는 여기에 있어"
   
3. 클라이언트는 SYN+ACK 패킷을 수신후에 SYN 플래그를 0으로 설정후 ACK패킷을 서버에 전달한다  
    `의미` : "ok"
   
   
### 연결 종료
tcp 연결을 종료하고 싶을때 4번 패킷을 송수신하는데 four way handshake라고 한다  

**연결성 종료 순서**
1. 클라이언트쪽에서 FIN 플래그 비트를 1로 설정하고 서버쪽으로 전송한다  
    `의미` : "나 이제 너와 그만하고 싶어.."
   
2. 서버는 ACK 패킷을 클라이언트 쪽으로 전달한다  
    `의미` : "어? 알겠어.. 잠시만.."
   
3. 서버는 FIN 패킷을 클라이언트 쪽으로 전달한다  
   `의미` : "나 이제 준비가 됬어!"
4. 클라이언트는 ACK 패킷을 서버에게 전달한다

5. 남은 데이터가 들어올 수 있도록 잠시동안 세션을 유지한 뒤 닫는다

## 혼잡제어
흐름제어와 다르게 혼잡제어는 종단간 통신에 사용되는 네트워크에 패킷이  
너무 과도하게 몰려서 패킷손실이 되지 않도록  
TCP 차원에서 송신량 억제를 통해서 네트워크로 가는 패킷을 억제하는 것을 이야기한다  

### 용어 설명
- `RTT` : 왕복 시간
- `cwnd` : 송신자가 네트워크로 보낼수있는 최대 크기
- `MSS` : 애플리케이션 계층 데이터에 대한 최대 크기
- `ssthresh` : slow start threshold의 약자로 슬로우 스타트의 임계치 ssthresh는 혼잡이 검출되었을 시점의 cwnd 값의 반으로 설정한다
### 슬로 스타트
cwnd 값을 1MSS에서 시작하여서 전송한 세그먼트가 첫번째 응답을 받을 때마다 cwnd*2를 한다  
타임아웃에 의한 손실이 있을 때 cwnd를 1로 수정하고 새로 시작한다  
 
**슬로 스타트 끝나는 시점**  
슬로 스타트는 지수적으로 cwnd값을 증가시킨다  
그러다가 혼잡에 마주하면 1로 변경하고 ssthresh = cwnd/2의 값으로 설정이된다  
다음에 cwnd값이 ssthresh에 같거나 넘어서게 된다면 슬로 스타터를 끝내고 혼잡 회피로 넘어간다  

**이유**  
8에서 걸렸다면 cwnd = 1, ssthresh = 4로 설정이 된다  
4값은 혼잡이 발생하기전에 보낸 cwnd 값으로 생각할 수 도 있다  
그러므로 4이상의 값을 보내면 혼잡이 발생하기 때문에 그 뒤로도 지수적으로 증가하는 것은 의미가 없기 때문이다  

### 혼잡 회피
슬로 스타트에서는 지수적으로 증가한것에 반하여  
혼잡 회피는 슬로 스타트에서 안되니깐 변경되 설정이므로 지수보다는 적게 증가해야한다  
그러므로 cwnd 값을 세그먼트의 ack를 모두 응답받은 다음에 1MSS만큼 증가시킨다

### 빠른 회복
슬로 스타트와 혼잡 회피가 TCP에 필수인 반면에 빠른 회복은 선택적 사항이다  
빠른 회복은 슬로 스타터 + 혼잡 회피와 다르게  
cwnd를 1로 변경하는 것이 아니라 cwnd를 cwnd/2로 설정하고 거기서 부터 지수적으로 증가한다  
만약 타임아웃이 발생한다면 슬로 스타트로 변경된다  

