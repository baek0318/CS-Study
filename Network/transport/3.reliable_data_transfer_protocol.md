# 신뢰적인 데이터 전달 프로토콜의 구축
>Author: 백승화  
>Created: 2021년 10월 1일  
>Tags: `rdt`

### rdt란
- `reliable data transfer`의 약자로써 신뢰적 데이터 전송을 뜻한다  
- `가정` : 모든 데이터는 보내어진 순서대로 전달될것이라는 가정

## rdt1.0
### rdt1.0이란
완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송을 이야기한다

**완벽하게 신뢰적인 채널이란**  
보내는 도중에 비트오류나 패킷손실이 존재하지 않는 채널을 이야기한다

## rdt2.0
### rdt2.0이란
비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송을 이야기한다

**비트 오류가 존재하는 채널이란**  
보내는 도중에 데이터 내부가 망가질 수 있는 채널을 이야기한다

### 비트 오류를 해결하기 위해 rdt2.0에서 구현한 기능
1. 오류검출
    - 비트 오류가 발생했을 때 수신자가 확인할 수 있는 방법이 필요하다 ➡️ 체크섬 필드
2. 수신자 피드백
   - 수신자가 제대로 데이터를 받았다면 `ACK` 응답을 보낸다  
    - 수신자가 제대로 데이터를 받지 못했다면 `NAK` 응답을 보낸다
3. 재전송
    - 오류가 있는 패킷이였다면 송신자가 재전송한다
    
### rdt2.0의 문제점
ACK, NAK 패킷에 오류가 있을거라는 가정을 하지 않는다

**문제점 해결방법**
- 왜곡된 ACK, NAK를 받은 경우에는 현제 데이터를 재전송하는 것이다

**재전송의 문제점**
- 중복 패킷이 발생할 수 있는데 정확히 어디의 중복인지 알기가 어렵다

**중복 패킷의 해결방법**
- 패킷마다 순서번호를 매김으로 어디 데이터 중복인지 체크할 수 있다


## rdt3.0
### rdt3.0이란
비트 오류와 손실 있는 채널 상에서의 신뢰적 데이터 전송을 이야기한다

**비트 오류와 손실이 있는 채널이란**  
보내는 도중에 비트오류나 패킷 손실이 존재하는 채널을 이야기한다

### 패킷 손실을 해결하기 위한 방법
- 카운트다운 타이머를 사용한다

**타이머의 동작원리**
1. 매 패킷마다 타이머를 시작한다
2. 타이머가 시간이 다되거나 도중에 알맞은 데이터가 올때 적당한 행동을 취한다
3. 타이머를 멈춘다

### rdt3.0의 문제점
전송 후 ACK, NAK 패킷을 받기 전까지 대기한다는 것이다 ➡️ 블록킹이 된다

### 해결방법
- 파이프라이닝 기술을 통해서 해결가능하다

## 파이프라이닝
rdt3.0의 문제점으로 전송 후 대기를 들 수 있다  
이부분을 해결하기 위한 방법으로써  
ack 응답 패킷을 송신자가 전달받지 않더라도 송신자가 수신자한테 데이터 패킷을 전달해서  
채널을 효율적으로 사용할 수 있게 만드는것을 이야기한다

### 파이프라이닝을 위한 요구사항
- 순서 범위가 커져야한다
   - 한 개 이상의 패킷을 연속해서 전달할 것이기 때문이다
- 송신측과 수신측은 한개 이상의 패킷을 버퍼링해야한다
   - ack 응답을 아직 받지 않았거나 예정된 패킷을 아직 수신받지 못할 경우를 대비해서이다
- 패킷 손실, 손상 복구방법에 대해서 GBN, SR 프로토콜을 지원해야한다

### GBN

**GBN이란**  
`Go Back N`의 약자로써 N 범위내의 패킷이 손실된경우 N부터 재전송하는 방법을 이야기한다
>다른 이름으로는 N의 위치가 오른쪽으로 이동한기 때문에 `sliding window protocol`로 부르기도 한다

**N은?**  
여기서 얘기하는 N은 패킷을 보낼때 할당해줄 수 있는 순서번호의 범위를 이야기힌다    
보통은 N을 `윈도우 크기`로 부르기도 한다

**ACK 수신 방법**  
GBN에서는 ACK를 수신할떄 cumulativce ack의 방식을 통하여서 ack를 수신한다  
>`cumulative ack` : 순서대로 ack를 수신하고 다음 순서가 아닌 ack를 받지 않는 것을 이야기한다

**타임아웃 이벤트 처리 방법**  
확인 응답 받지 못한 패킷을 기준으로 타이머를 작동시켜서   
패킷 손실이 일어난 지점의 패킷부터 N까지의 패킷을 다시 재송신한다
>단일 타이머를 사용한다  

**장점**  
- 수신자는 다음 순서에 대한 정보만 가지고 있어도 됨으로 단순해진다  

**단점**  
- 하나의 패킷을 자주 손실할경우 너무 많은 패킷이 재전송되어야 한다   

### SR

**SR이란**
`Selective Repeat`의 약자로써 손실된 패킷만 선택적으로 재전송하는 방법을 이야기한다  
GBN에서는 너무 많은 패킷을 재전송해야되는 단점을 보완하기 위한 방법으로 볼 수 있다  

**ACK 수신방법**  
GBN과 달리 SR에서는 다음 순서에 맞지 않는 ACK 패킷이 송신자측으로 전달할 수 있고  
그 패킷을 받아서 송신자측에서 받았다고 처리할 수 있다  
그리고 해당 ack 패킷이 base랑 일치한다면 윈도우를 오른쪽으로 이동시킨다  

**타임아웃 이벤트 처리 방법**
GBN과 달리 개별 패킷에 대해서 ack 응답을 재전송하기 때문에 개별 패킷이 타이머를 가지고 있어야한다  
그래서 개별 패킷이 손실이 되고 타임아웃이 발생한 경우 해당 패킷만 재전송한다  

**장점**  
- 손실된 개별 패킷만 재전송하면 되서 파이프라이닝 공간을 효율적으로 사용할 수 있다  

**단점**  
- 순서번호의 공간과 윈도우의 크기가 동일한 경우  
  실패해서 재전송하는 패킷과 차례가 와서 정상적으로 전송되는 패킷과 순서번호가 같은 경우  
  구분을 하지 못하기 때문에  
  윈도우의 크기를 순서번호의 크기의 절반정도 밖에 사용하지 못한다  
  그러므로 한번에 전송할 수 있는 데이터의 크기가 줄어들게 되는 것이 단점이다  
  